name: Upload Required Packages to CodeArtifact with Lockfile

on:
  push:
    branches:
      - master

jobs:
  upload-packages:
    runs-on: ubuntu-latest

    permissions:
      contents: write
      id-token: write

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Install Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install tools
        run: |
          pip install awscli packaging

      - name: Prepare lockfile
        run: |
          if [ ! -f approved_packages.lock ]; then
            echo "Creating empty approved_packages.lock file."
            touch approved_packages.lock
          else
            echo "approved_packages.lock already exists."
          fi

      - name: Determine packages to process
        id: new_packages
        run: |
          set -e
          set -x
          ls -l
          
          sort required_packages.txt | grep -vE '^\s*#|^\s*$' > current.txt || true
          sort approved_packages.lock | grep -vE '^\s*#|^\s*$' > lock_sorted.txt || true

          while IFS= read -r line; do
            if [[ ! "$line" =~ ^[a-zA-Z0-9_-]+==[0-9]+\.[0-9]+(\.[0-9]+)?$ ]]; then
              echo "Error: Invalid package format in required_packages.txt: '$line'"
              exit 1
            fi
          done < current.txt

          comm -23 current.txt lock_sorted.txt > new_packages.txt 2>/dev/null || true

          echo "New packages to process:"
          cat new_packages.txt || echo "(none)"

          if [ -s new_packages.txt ]; then
            NEW_PACKAGES=$(cat new_packages.txt | grep -vE '^\s*#|^\s*$')
            echo "NEW_PACKAGES<<EOF" >> $GITHUB_ENV
            echo "$NEW_PACKAGES" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
          else
            echo "NEW_PACKAGES=" >> $GITHUB_ENV
          fi

      - name: Download and upload new packages
        env:
          PACKAGES_TO_PROCESS: ${{ env.NEW_PACKAGES }}
          DOMAIN: ${{ secrets.DOMAIN_NAME }}
          REPO: ${{ secrets.REPO_NAME }}
        run: |
          mkdir -p approved_pkgs

          if [ -z "$PACKAGES_TO_PROCESS" ]; then
            echo "No new packages to process."
            exit 0
          fi

          echo "Packages to process:"
          echo "$PACKAGES_TO_PROCESS"

          echo "$PACKAGES_TO_PROCESS" | while IFS= read -r line; do
            [[ -z "$line" || "$line" =~ ^# ]] && continue

            echo "Downloading package: $line"
            if ! pip download "$line" -d approved_pkgs --no-binary=:all:; then
              echo "Error: Failed to download package '$line'. Continuing with next package."
              continue
            fi
          done

          echo "Processing downloaded files..."
          for file in approved_pkgs/*; do
            [ -f "$file" ] || continue
            fname=$(basename "$file")

            # Extract package name and version using bash
            # Remove .tar.gz extension (only source tarballs are downloaded)
            base_name="${fname%.tar.gz}"
            
            # Split on last hyphen to get name and version
            if [[ "$base_name" =~ ^(.+)-([0-9]+\.[0-9]+.*)$ ]]; then
              pkg_raw="${BASH_REMATCH[1]}"
              ver="${BASH_REMATCH[2]}"
              
              # Normalize package name (lowercase, replace _ and - with -)
              pkg=$(echo "$pkg_raw" | tr '[:upper:]' '[:lower:]' | tr '_' '-')
              
              echo "Parsed: $fname -> package=$pkg, version=$ver"
            else
              echo "Error: Could not parse package/version from '$fname', skipping."
              continue
            fi

            if [ -z "$pkg" ] || [ -z "$ver" ]; then
              echo "Error: Empty package or version from '$fname', skipping."
              continue
            fi

            echo "Checking $pkg==$ver ..."
            exists=$(aws codeartifact list-package-versions \
              --domain "$DOMAIN" \
              --repository "$REPO" \
              --format pypi \
              --package "$pkg" \
              --query "versions[?version=='$ver'].version" \
              --output text 2>/dev/null || true)

            if [ -n "$exists" ]; then
              echo "$pkg==$ver already exists, skipping."
              continue
            fi

            echo "Uploading $fname ..."
            if aws codeartifact publish-package-version \
              --domain "$DOMAIN" \
              --repository "$REPO" \
              --format pypi \
              --package "$pkg" \
              --package-version "$ver" \
              --asset-name "$fname" \
              --asset fileb://"$file"; then
              echo "Successfully uploaded $pkg==$ver"
              echo "$pkg==$ver" >> approved_packages.lock
            else
              echo "Error: Failed to upload $pkg==$ver"
            fi
          done

      - name: Commit updated lockfile
        uses: stefanzweifel/git-auto-commit-action@v4
        with:
          commit_message: "Update approved_packages.lock with newly uploaded packages"
          file_pattern: approved_packages.lock
          branch: master
