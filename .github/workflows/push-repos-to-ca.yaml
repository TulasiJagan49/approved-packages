name: Upload Required Packages to CodeArtifact with Lockfile

on:
  push:
    branches:
      - master

jobs:
  upload-packages:
    runs-on: ubuntu-latest

    permissions:
      contents: write
      id-token: write

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Needed to get previous commit

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Install Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install tools
        run: |
          pip install awscli packaging

      - name: Prepare lockfile
        run: |
          if [ ! -f approved_packages.lock ]; then
            echo "Creating empty approved_packages.lock file."
            touch approved_packages.lock
          else
            echo "approved_packages.lock already exists."
          fi

      - name: Determine packages to process
        id: new_packages
        run: |
          set -e
          set -x
          ls -l
          
          # Clean and sort files
          sort required_packages.txt | grep -vE '^\s*#|^\s*$' > current.txt || true
          sort approved_packages.lock | grep -vE '^\s*#|^\s*$' > lock_sorted.txt || true

          # Validate package format in required_packages.txt
          while IFS= read -r line; do
            if [[ ! "$line" =~ ^[a-zA-Z0-9_-]+==[0-9]+\.[0-9]+(\.[0-9]+)?$ ]]; then
              echo "Error: Invalid package format in required_packages.txt: '$line'"
              exit 1
            fi
          done < current.txt

          # Get new packages not yet in lockfile
          comm -23 current.txt lock_sorted.txt > new_packages.txt 2>/dev/null || true

          echo "New packages to process:"
          cat new_packages.txt || echo "(none)"

          # Ensure NEW_PACKAGES is clean and properly formatted
          if [ -s new_packages.txt ]; then
            # Remove any empty lines or comments, and join with newlines
            NEW_PACKAGES=$(cat new_packages.txt | grep -vE '^\s*#|^\s*$' | tr '\n' '\n')
            echo "NEW_PACKAGES<<EOF" >> $GITHUB_ENV
            echo -n "$NEW_PACKAGES" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
          else
            echo "NEW_PACKAGES=" >> $GITHUB_ENV
          fi

      - name: Download and upload new packages
        run: |
          PACKAGES_TO_PROCESS="${{ env.NEW_PACKAGES }}"
          DOMAIN="${{ secrets.DOMAIN_NAME }}"
          REPO="${{ secrets.REPO_NAME }}"

          mkdir -p approved_pkgs

          if [ -z "$PACKAGES_TO_PROCESS" ]; then
            echo "No new packages to process."
            exit 0
          fi

          echo "Packages to process:"
          echo "$PACKAGES_TO_PROCESS"

          # Process each package with error handling
          echo "$PACKAGES_TO_PROCESS" | while IFS= read -r line; do
            # Skip empty lines or comments
            [[ -z "$line" || "$line" =~ ^# ]] && continue

            echo "Downloading package: $line"
            if ! pip download "$line" -d approved_pkgs --no-binary=:all:; then
              echo "Error: Failed to download package '$line'. Continuing with next package."
              continue
            fi
          done

          echo "Processing downloaded files..."
          for file in approved_pkgs/*; do
            [ -f "$file" ] || continue  # Skip if no files exist
            fname=$(basename "$file")

            # Parse package name and version reliably
            read pkg ver <<< $(python3 - <<END
              from packaging.utils import canonicalize_name
              import re, sys

              fname = "$fname"
              fname_no_ext = re.sub(r'(\.tar\.gz|\.zip|\.whl)$', '', fname)
              parts = fname_no_ext.rsplit('-', maxsplit=1)
              if len(parts) != 2:
                  sys.exit()
              name, ver = parts
              print(canonicalize_name(name), ver)
              END
            )

            if [ -z "$pkg" ] || [ -z "$ver" ]; then
              echo "Error: Could not parse package/version from '$fname', skipping."
              continue
            fi

            echo "Checking $pkg==$ver ..."
            exists=$(aws codeartifact list-package-versions \
              --domain "$DOMAIN" \
              --repository "$REPO" \
              --format pypi \
              --package "$pkg" \
              --query "versions[?version=='$ver'].version" \
              --output text 2>/dev/null || true)

            if [ -n "$exists" ]; then
              echo "$pkg==$ver already exists, skipping."
              continue
            fi

            echo "Uploading $fname ..."
            if aws codeartifact publish-package-version \
              --domain "$DOMAIN" \
              --repository "$REPO" \
              --format pypi \
              --package "$pkg" \
              --package-version "$ver" \
              --asset-name "$fname" \
              --asset fileb://"$file"; then
              echo "Successfully uploaded $pkg==$ver"
              # Append successfully uploaded package to lockfile
              echo "$pkg==$ver" >> approved_packages.lock
            else
              echo "Error: Failed to upload $pkg==$ver"
            fi
          done

      - name: Commit updated lockfile
        uses: stefanzweifel/git-auto-commit-action@v4
        with:
          commit_message: "Update approved_packages.lock with newly uploaded packages"
          file_pattern: approved_packages.lock
          branch: master
